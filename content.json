{"meta":{"title":"PARK JI EUN","subtitle":"GOLD24PARK","description":"PARK JI EUN's portfolio & blog","author":"PARK JI EUN","url":"http://lx5475.github.io"},"pages":[],"posts":[{"title":"대만 용산사 점괘 해석 1-20수","slug":"longshan-1-20","date":"2017-07-18T12:42:31.000Z","updated":"2017-07-18T12:43:59.000Z","comments":true,"path":"2017/07/18/longshan-1-20/","link":"","permalink":"http://lx5475.github.io/2017/07/18/longshan-1-20/","excerpt":"","text":"대만 용산사 점괘 해석 1-20수일본 블로그를 참고하여 번역한 것입니다.더 나은 번역이 있으시다면 댓글로 언제든 알려주세요! 여러분의 참여가 더 좋은 해석을 만듭니다. 1-10수제 1수중중하늘을 열기 좋은 시기이다.(天開地闢結良緣)길상의 때이며, 각종 조건은 다 갖췄다.(日吉時良萬事全)이 제비를 뽑았다는 것은 대단한 일이다.(若得此籤非小可)올바른 행동을 하고 있으면, 제왕에게까지 목소리가 걸릴 것이다.(人行中正帝王宣) 이 가장 제비는 덴노 제비라고도 불리며, 모든 기원 중에서도 특히 왕과 될 운수를 나타내는 최고의 제비라고 불리고 있습니다.사업을 하고 있다면 더욱 더 발전하고 투자를 하고 있다면 이익이 늘어나면서 정치적 지위는 점점 높아집니다. 각 분야에서 왕과 될 자질과 조건이 갖추어졌다는 틀림없는 당첨 복권입니다. 제 2수중사정은 아직 익지 않고 현재 위치를 다져야 한다.(鯨魚未化守江湖)더 높은 곳을 목표로 하기 때문에 지금의 입장은 버리는 때가 아니다.(未許升騰離碧波)세월이 지나면 당신은 성장하고 조건이 된다.(異日?嶸身變態)그때까지 자기를 닦고, 문을 뚫틀을 깨는 시기를 기다리는 것이다.(從?一躍禹門過) 고래는 어류(포유류지만, 제비에서 생선의 일종입니다.)의 왕이 되는데 그것이 아직 미성숙하다는 뜻이예요. 바다 바람이나 파도에 헤엄이며 지금의 위치(강호)을 지키는 편이 좋다는 것을 나타내고 있습니다. 일단 성장이 끝나면 왕이 될 자질을 갖고 있으므로, 지금의 자리에서 성장과 시기를 기다린다는 제비입니다. 제 3수하고난 속을 왔다 갔다 .(衝風冒雨去還歸)매일 고생 하는 제비 비슷하다.(役役勞身似燕兒)진흙을 가득히 묻히고 둥지를 만들어도(啣得泥來呈疊後)마지막에는 다시 흙으로 돌아갈 뿐이다.(到頭疊壞復成泥) 연자지집이라는 고사에 비유되는 무정한 제비입니다. 비바람 속을 누비고 둥지를 틀제비의 고생과 고생하고 만든 둥지가 다시 흙으로 돌아가는 모양을 나타내고 있습니다. 지금의 노력이 모두 헛수고로 끝나는 것을 시사하고 있어, 남에게 공을 가로채거나 의미 없는 일을 되풀이하고 있거나 그렇다고 손을 빼는 것도 허용되지 않는다는 어려운 상황을 암시하고 있습니다. 제 4수중거울(능화경)이 깨졌다 다시 둥그렇게 되니, (菱花鏡破復重圓)여자는 다시 남편을 구하고 남자는 다시 혼인하네.(女再求夫男再婚)이리하여 문려(門閭, 집앞의 문과 마을 어귀의 문)가 다시 새로워지니(自此門閭重改換)복록이 더해지고 자손도 복을 받네.(更添福祿與兒孫) 이 첨(제비)가 암시하는 것은 원만한 운세라 하겠습니다. 능화경(菱花鏡, 릉화경)은 마름 문양이 새겨진 청동 거울로서 차이나의 당나라 때 유행한 것이라 합니다. 여기서 결혼이 깨지고 다시 새로운 결혼을 하는 것을 말하는 것보다는 대개 불화했던 부부가 다시 원만해지는 것을 의미하는 것입니다. 시에 언급되는 “破鏡重圓”이라는 고사도 부부가 다시 만나는 일입니다. 각각의 운세를 보면, 거래(사업)은 성공적이고, 애정(혼인)은 이루어집니다. 재물운은 가을과 겨울에 왕성합니다. 자신의 운은 좋고 가을과 겨울에 특히 좋습니다. 반면에 집안은 불리합니다. 농사나 가축은 잘 됩니다. 사람을 찾으면 찾게 되고, 여행도 순조롭습니다. 임신은 신의 보호를 기도해야 합니다. 조상 무덤 일은 길하고, 소송에는 불리합니다. 병에 걸린 사람이 있으면 하늘에 복을 기도해야 합니다. 잃어버린 물건은 천천히 찾아집니다. 이사는 하지 않는 것이 좋습니다. 제 5수중첫 괭이로 우물을 찾고있다.(一鋤掘地要求泉)그러지마라, 우선 몇번이나 노력하는 게 먼저이다.(努力求之得最先)이상적인 파트너와 언제 만날 수 있을지 모르겠다.(無意俄然遇知己)그러나 그런 사람과 손을 잡고 간신히 성공할 수 있다.(相逢?手上?天) 일을 서두르지 말고 계속 해나가는 것을 암시하며 우연의 만남이 얼마나 소중한가를 설명하는 제비입니다. 서두르면 일을 그르친다는 의미와 천생연분 등과도 통하는 제비입니다. 제 6수중자신을 희생하고 남 때문에 다하는 것.(投身巖下飼於?)필요한 것은 다른 사람 이며, 자신이 아니다.(須是還他大丈夫)이처럼 남을 위해 자신을 버리는 일은 자주 있는 일이 아니다.(捨己也應難再得)그런 사람은 천하에 드물다.(通行天下此人無) 타인을 자기를 버릴 수 있는 사람이야말로 천하의 영웅이라고 합니다. 모든 것을 버린 때 사물의 본질이 보이고, 또 그런 때에 아군이 되어 주는 사람이야말로 진정한 벗이라는 식으로 해석됩니다. 반대로 그런 친구나 사람이 얼마나 적은지를 개탄하고 있는 점괘라고도 할 수 있습니다. 우선은 이타만을 생각하고 자신을 희생하고 타인에게 힘쓰고 봅시다. 제 7수하수많은 고생, 숱한 위험,(奔波役役重重險)앞으로도 또 물을 메고 산을 올라가야 한다.(帶水拖泥又渡山)지금의 자리를 떠나서 다른 곳에 갈 생각도(更慮他方求別用)그 장소는 더욱 멀리 있는 것이다.(千山萬水未能還) 지금까지 힘들게 고생했는데, 앞으로는 더욱 혼란에 빠지는 것 보이는 점괘입니다. 또한 지금의 장소에서 도망 치려고 생각해도 거기 가려면 큰 어려움이 따르더라도 살고 있습니다. 바로 만사휴의의 점괘입니다. 제 8수상상오래전에 심은 세한송백이(歲寒松柏古栽培)비,눈,바람,서리 등 온갖 불순한 기후에도 쓰러지지 않고(雨雪風霜總不?)마침내 크게 쓰일 날을 맞아(異日必當成大用)이름을 날리며 동량재로 쓰이게 된다.(功名作個棟樑材) 소중하게 어렵게 키운 나무가 동량재가 되어 크게 쓰임을 받는 전도가 양양한 점괘로 범사가 바르게 선다 즉 길(吉)하다는 내용입니다. 즉, 지금까지 쌓아 온 선행과 노력이 이제 겨우 열매를 맺을 때가 왔다는 제비입니다. 지금까지 힘든 일은 모두 웃어 넘기고, 그것들을 바탕으로 스텝업 할 때입니다. 소중하게 고생해서 키운 목재가 좋은 건축 자재로서 큰 건물이 된다는 전도 양양의 제비입니다. 제 9수상상수많은 사소한 일이 당신의 심중을 귀찮게 하고 있다.(勞苦問我心中事)지금 여기에서 다시 객관적으로 일을 재고하고 보는 것이다.(此意偏宜說向公)지난 잘못은 없었는가?앞으로 이루는 일은 옳은가.거울을 보며 스스로 자신을 찾는 것이다.(一片靈臺明似鏡)지금이야말로 자신을 이루는 것을 분명히 알수있을 것이다.(恰如明月正當空) 매우 깊이 있는 제비입니다. 지금까지의 행동에 실수가 없으면 아무것도 흔들림이 없습니다. 자신이 하고 온 것과 상황을 생각하고, 뭔가 걸리는 게 있으면 그것을 해결해야 한다는 제비입니다. 이 제비가 나오면 냉정하게 객관적으로 철저히 반성하고 자신을 되돌아보세요. 그러면 해야 할 일이 저절로 드러납니다. 제 10수하당신이 정말 필요한 것은 안에 있다.(?藏無價寶和珍)밖에서 답을 구할 것이 아니다.(只管他?外處尋)제 등을 가지고 불을 찾으러 가는 것이나 같다.(好似將燈來?火)만약 그렇게 하지 않으면 모든 것이 허사로 끝날 것이다.(不如安靜莫勞心) 꽝인 제비치고는 아주 부드러운 시작입니다. 그러나 마지막에는 말을 안 지키면 모든 게 수포가 된다는 조금 무서운 글이 쓰여 있습니다. 우선 눈 앞에 있는 일은 뒤로하고 다른 일에 신경을 써주어야 합니다. 일단 저지르고 본다는 식의 일은 지금 하면 안됩니다. 11-20수제 11수상상특별히 기쁜 좋은 일을 바랐는데(欲求好事喜非常)어찌하랴 사돈이 잠시 바빴을 뿐이네.(爭相姻親只暫忙)결국 마침내 좋은 일이 이루어지고(畢竟到頭成好事)귀인이 귀인의 고을로 맞이해 들이리.(貴人接引貴人?) 결혼을 바라는 상황에서, 잠시 결혼할 집안과 어려움이 있지만 곧 잘 이루어질 것이라는 말을 하고 있습니다. 전체적으로 희망적인 메시지입니다. 세부 운세는 다음과 같습니다. 거래(사업)운, 혼인(애정)운, 재물운, 자신에 대한 운, 집안에 대한 운 등은 모두 길합니다. 가축이나 농사에 대한 운은 중간쯤 되며, 사람을 찾으면 찾아지고, 여행은 목적지에 이르지 못할 운세입니다. 임신하면 아들을 낳을 운세이며, 조상 무덤일에 대한 운세, 소송에 대한 운세는 길합니다. 병에 걸렸을 때는 별(북두칠성, 칠성님)에게 제사를 지내야 좋은 운세이고, 잃어버린 물건은 동쪽에서 찾아질 것이며, 이사 혹은 이직은 운세가 아주 좋습니다. 지금은 어렵더라도 좋은 일이 일어날 것입니다. 그리고 그렇게 되면 그 기회와 여력을 이용하여 미래를 대비하는 준비를 한다면 지혜로운 행동이 될 것입니다. 제 12수상상고난의 시간을 넘어 바로 지금 이 순간.(時臨否極泰當來)어둠에서 벗어날 때가 왔다.(??從君出暗埃)호랑이와 토끼라면 한층 더 좋다.(若欲卯寅佳信至)뜻을 세우는 지금이야말로 목적을 달성할 때이다.(管?立志事和諧) 호랑이와 토끼의 시기란 호년 면한 해 음력의 한 두달, 그리고 토끼, 호랑이의 날을 나타냅니다. 길고 어두운 고난의 때를 벗어나기 바로 지금 일이 되고 있음을 알리고 있습니다. 목표를 명확히 하고 지금이야말로 그것을 향해서 내디딜 때다라는 강력한 제비입니다. 제 13수상상어렸을 때부터 운이 좋았다.(自小生身富貴家)눈앞의 모든 것이 장밋빛으로 빛나고 있다.(眼前萬事總奢華)지금부터 앞의 운도 더욱 좋을 것이다.(要君賜受金魚袋)세계에 이름을 떨쳐 발전을 목표로 할 것이다.(四海傳名足可誇) 운이 좋음을 기리는 제비입니다. 그리고 앞으로도 그 운이 좋은 점은 지속하겠다고 합니다. 사물은 모두 상대적입니다. 당신이 운이 좋았다고 믿을 수만 있다면 앞으로 점점 발전이 있을 것입니다. 제 14수대길선학이 바구니에서 튀어나온 것처럼(宛如仙鶴出樊籠)앞으로 어디로 날아가는 것도 자유롭다.(脫却羈?處處通)당신의 앞길을 가로막는 것은 아무것도 없다.(南北東西無障碍)구름을 넘어 한층 더 높은 곳으로 날아오를 것이다.(任君直上九?中) 이제 바구니를 튀어나와 당신이 원하는 것을 좋아하는 대로 이룹시다. 당신을 멈추는 것, 방해하는 것은 아무것도 없습니다. 어디로 날아오르는 무엇을 하는 것도 자유입니다. 지금까지 바라만 봤었던 구름을 넘어 아득히 높은 곳을 지향한다는 기분 좋은 대길 제비입니다. 제 15수하남의 원한과 분노를 받아들이는 것은 매우 어렵다.(觸人口氣最難?)갑작스런 재난이 눈앞에 있다.(忽有災危禍到門)둥지가 부서진 새끼는 어디도 갈 곳이 없다.(卵破巢空無宿處)단지 몸을 숨긴 재앙이 지나가길 기다릴 뿐이다.(深?穩便把心存) 시작부터 갑자기 불안을 부추기는 제비입니다. 적의나 재앙 등 나쁜 일만 적힌 꽝 제비입니다. 모든 것을 참고 견디는 것만이 유일한 방법이라고도 말합니다. 그것이 가능한지 당신의 담력이 요구되고 있습니다. 일단 참아봅시다. 제 16수중상찌푸린 눈살과 깊은 생각을 잠시 내려놓으니,(?眉思慮暫時開)곧 구름이 걷히고 태양이 나오는 것이 보이네.(咫尺雲開見日來)마치 진흙 가운데 옥처럼,(宛如?泥中片玉)뛰어난 공인(工人)이 들어 올려 진흙에서 나오네.(良工一?出塵埃) 여기서 공인(工人)은 앞의 풀이에서의 귀인이며 고사에서는 신종에 해당합니다. ‘옥’은 고사에서 해서이며, 이 제비를 뽑은 사람을 암시합니다. 각각의 운세는 다음과 같습니다. 교역(사업)은 이루어지며 혼인(애정운) 역시 이루어집니다. 재물을 구하는 것은 겨울에 길합니다. 자기 자신은 가을과 겨울에 길한 운세이지만, 집안은 불안합니다. 가축은 보통이고 농사는 복을 기원해야 합니다. 사람을 찾으면 보이고, 여행은 도달합니다. 임신은 헛됩니다. 무덤 일은 평안하고, 소송은 불리합니다. 질병은 복을 기원해야 하고, 잃어버린 물건은 찾기 어렵습니다. 이사는 하지 말고 그대로 있는 것이 좋습니다. 해서의 청렴함과 강직함은 존경스럽습니다. 단순히 스스로 청렴함에 그치는 것이 아니라 그것을 관리들에게 강력히 요구했으며 심지어 황제에게도 목숨을 걸고 직접 충고를 했습니다. 모함을 받아 벼슬에서 물러나 있었지만 역시 다시 불려 쓰임을 받았습니다. 그런 삶을 본받는다면 무척 보람된 일일 것입니다. 제 17수중쓸데없는 말과 사람들의 시비에 귀 기울이지 말고,(莫聽閑言與是非)아침 저녁으로 아미타불을 염송하는 것이 낫네. (晨昏只好念阿彌)허망한 말을 진실이라 여긴다면,(若將妄語??實)그림의 떡으로 어찌 허기진 배를 채울 수 있으리오.(??如何療得飢) 남들이 하는 쓸데없는 말에 좌우되지 말고 자신의 중심을 잡기를 주문하고 있습니다. 각각의 운세는 이렇습니다. 교역(사업, 비즈니스)는 순조롭습니다. 혼인(애정운)은 막힙니다. 재물을 구하면 생깁니다. 자신에 대한 운세는 길하고, 집안에 대해서는 신에게 복을 기원해야 합니다. 가축은 불리하고 농사는 이른 것이 좋습니다(일찍 일을 시작하라는 의미). 사람을 찾으면 보이게 되고, 여행은 늦어집니다. 임신하면 안심해도 됩니다. 무덤 일은 길하여 해도 됩니다. 소송(혹은 관청과의 일)은 원만히 해결이 될 것입니다. 병에 대해서는 還願(환원)이라고 되어 있는데, 신에게 기원하라는 뜻입니다. 곧, 병이 중하여 낫기 위해서는 신의 가호가 필요하다는 뜻입니다. 잃어버린 물건이 있으면 찾아지지 않을 것이며, 이사는 하지 않고 그대로 지키고 있는 것이 좋습니다. 운세는 좋아도 나빠도 모두 자신에게 도움이 되도록 생각할 수 있는 것이며, 또 그래야 합니다. 한비는 뛰어난 재능을 지녔고, 진시황을 만나 크게 인정받을 기회가 있었는데도 이사의 술수에 넘어가서 좌절되고 말았습니다. 감옥에 갇힐 때도 이사가 친구로서 자기를 도와준다고 여겼습니다. 옆에서 자신에게 웃고 있는 사람이 칼을 가는 적일 수도 있고, 잔소리하고 싫은 소리하는 배우자나 애인이나 가족이 실은 자신을 가장 사랑하고 자신에게 가장 이로운 사람일 수도 있습니다. 자신의 중심을 잘 잡는다면 한비와 이사의 이야기가 많은 시사점을 던져 줄 것입니다. 제 18수상상해가 가라앉고 달이 떠오르다.(金烏西墜?東臨)예부터 이를 매일 반복하는 것이다.(日夜循環恒古今)수행을 실시하는 사람이 길을 열고(僧道得之無不利)다른이들은 만족할 것이다.(工商農士各開心) 그동안 그늘에서 열심히 노력해왔던 당신이 드디어 빛나는 때가 왔다는 희망적인 제비입니다. 제 19수중지금은 물의 흐름이 빨라 배를 낼 때가 아니다.(急水灘頭放艇時)무슨 계획이 있더라도 지금 혼란이 지나가고 나서부터다.(狂風作浪欲何?)우선은 폭풍이 지나가는 것을 그저 기다릴 것.(待他浪靜風停後)짐을 실은 배는 파도가 잔잔한 때에 출항하는 것이다.(穩載船歸過不危) 모든 일에는 제 떼라는 것이 있습니다. 지금은 바다가 혼란스럽기 때문에 출항하지 말라고 합니다. 지금은 무엇을 해도 결코 잘되지 않습니다. 하지만 폭풍은 언젠가 반드시 그칩니다. 그러니 점잖게 시기를 기다립시다 . 제 20수상상봄에 계속 내리던 비가 기쁘게도 비로소 개었고,(當春久雨喜初晴)달과 해는 점점 더 밝아지네.(玉?金烏漸漸明)옛일은 이미 이루어졌고 새로운 일도 완수되니, (舊事已成新事遂)어느덧 봉영(봉래산과 영주산으로 신선이 산다는 곳)으로 뛰어 오르리..(看看一跳入蓬瀛) 앞길이 창창하게 빛나고 새로운 경지가 펼칠 것임을 말하고 있습니다. 구체적인 운세는 다 좋지는 않습니다. 어려운 일에 처해 있다가 좋아지는 측면이 고려되고 있습니다. 사업(거래)은 시기를 기다려야 합니다. 혼인(애정)은 뜻대로 하라고 되어 있습니다. 재물은 아직 만나지 못합니다. 자신에 대해서는 복을 구해야 하며 (조심하라는 뜻) 집안에 대한 운세는 보통입니다. 가축과 농사의 운세는 좋지 않습니다. 사람을 찾으면 늦게 찾아집니다. 여행은 어려움을 만날 것입니다. 임신하면 딸을 낳습니다. 조상 무덤일은 그대로 있는 것이 길합니다. 소송은 화해할 것이며, 병에 대해서는 신에게 제사를 올려야 합니다. 잃어버린 물건은 찾게 될 것이며, 이사(이직)의 운세는 길합니다. 전체적으로 고진감래의 점괘입니다. 어렵더라도 정도(正道)를 지키고 견디어내면 멋진 보답이 기다리고 있을 것입니다.","categories":[{"name":"안녕용산사","slug":"안녕용산사","permalink":"http://lx5475.github.io/categories/안녕용산사/"}],"tags":[{"name":"대만","slug":"대만","permalink":"http://lx5475.github.io/tags/대만/"},{"name":"타이페이","slug":"타이페이","permalink":"http://lx5475.github.io/tags/타이페이/"},{"name":"용산사","slug":"용산사","permalink":"http://lx5475.github.io/tags/용산사/"},{"name":"점괘","slug":"점괘","permalink":"http://lx5475.github.io/tags/점괘/"},{"name":"해석","slug":"해석","permalink":"http://lx5475.github.io/tags/해석/"}]},{"title":"어플 개발 어떻게 시작하면되나요? 아무것도 몰라도 할 수 있을까요? Q&A","slug":"android-newbie","date":"2017-07-15T06:33:49.000Z","updated":"2017-07-15T07:30:55.000Z","comments":true,"path":"2017/07/15/android-newbie/","link":"","permalink":"http://lx5475.github.io/2017/07/15/android-newbie/","excerpt":"","text":"코딩 열풍 시대라…주위에 보면 앱 개발을 시작하려는 사람들이 많고전공자도 아닌데 앱 개발을 어떻게 시작하면 되는지 물어보는 사람들이 많다.나도 초보자긴하지만, 비전공자로 프로그래밍 언어도 모른채 앱 개발의 세계에 뛰어든 사람이라 같은 고민을 했기 때문에 나누어보려고한다.그래서 Q&amp;A 세션을 준비해보았다. Q 컴맹인데 어플 개발 할 수 있을까요? 컴퓨터를 잘 다루지 못해도 어플 개발은 당연히… 할 수 있다.처음 세팅만 해두면 그냥 문서작성처럼 코드만 만지작거리는 것이기 때문에 컴맹이랑은 관계가 없다.중요한 것은 문제(에러)가 발생했을 때 에러를 감지하고 구글에서 빨리 해결책을 검색해 찾아서 고칠 수 있는 능력이다. Q 안드로이드랑 Java언어, 뭐 부터 공부해야 할까요? 앱 만들려고 안드로이드 책을 샀는데… 책에는 안드로이드는 Java라는 프로그래밍 언어를 사용한다고 적혀있다. ㅋㅋㅋ프로그래밍 언어는 C언어 밖에 없는 줄알았는데 이런 언어도 있나보다 ^^ 라는 생각이든다.또 Java책을 사서 보니까 엄청 두껍고 이걸 어느세월에 다 떼서 안드로이드 들어가나 한숨만 나온다. 추천하는 팁은 이거다. Java 책에서 처음부터 상속까지만 빠르게 본다. 1장에 있는 자바의 역사 같은건 그냥 넘기자… 모든 코드를 다 외울 필요도 없다. 모르는 게 나오면 다시 찾아보면 되니까 ^o^ 객체 지향 개념을 익히는게 중요하다. 나는 객체라는 말도 너무 철학적이고 이상해서 이해하는데 오래걸렸다. 그래서 간단하게 객체에 대해서 이야기해주도록 하겠다. 객체 지향예를 들어, 카카오톡 같은 앱을 만든다고 해 보자. 카카오톡에는 친구 목록이있다. 친구를 클릭하면 여러가지 정보들을 볼 수 있다.별명(nickName), 전화번호(phoneNumber), 프로필 사진(profileImage)이있을 것이다.그러면 A친구의 전화번호를 얻고 싶을 땐 어떻게 하면될까?비유하자면 C언어같은 절차지향적 프로그램은 전지전능한 신(?)이 전화번호를 알려준다.하지만 Java같은 객체지향적 프로그램은 그 A친구가 직접 자신의 전화번호를 알려준다.친구와 관련된 모든 기능은 '친구 객체'에다 맡겨두는 것이다. * 쉽게 설명한다고 했는데 너무 복잡한것같기도...Java 코드로 표현하면 이렇게 된다.// 친구라는 객체class Friend &#123; private String phoneNumber; public Friend(String phoneNumber) &#123; this.phoneNumber = phoneNumber; &#125; public String getPhoneNumber() &#123; return this.phoneNumber; &#125;&#125;public void main() &#123; // A친구 만들기 Friend aFriend = new Friend(\"010-1234-5678\"); // A친구에게서 폰 번호 얻기 aFriend.getPhoneNumber(); // 010-1234-5678&#125; Q 뭐 부터 시작하면 좋을까요? 왕초보자 추천 튜토리얼 코스는 다음과 같다.여러분이 무엇을 만드려고 하던 이 과정은 꼭 필요하다고 개인적으로 생각한다. 1) Android Studio &amp; Android SDK 설치하기 2) Hello World 라고 적힌 화면을 보여주는 앱 만들기 3) 버튼 누르면 텍스트(TextView)가 바뀌는 앱 만들기 4) 버튼 누르면 화면이 전환되는 앱 만들기 5) 미리 입력한 목록(ListView)을 보여주는 앱 만들기 6) 사용자가 단어를 입력하여 목록에 추가하는 앱 만들기 7) Glide 또는 Picasso라는 라이브러리를 사용한 사진 앱 만들기 8) Firebase를 활용해 데이터베이스에서 정보를 불러오는 앱 만들기 (API를 잘 다룰 수 있도록 하기 위한 것) 이 정도라면 서버 프로그래밍을 할 줄 몰라도 어느정도 앱을 개발할 수 있게 된다! 언제한번… 튜토리얼을 만들어볼까 생각중이다.비디오가 좋을까 글이 좋을까 ㅋㅋ","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"앱 개발","slug":"앱-개발","permalink":"http://lx5475.github.io/tags/앱-개발/"},{"name":"하는 방법","slug":"하는-방법","permalink":"http://lx5475.github.io/tags/하는-방법/"}]},{"title":"안드로이드 인트로(스플래시) 화면을 만들어보자","slug":"android-splash","date":"2017-07-15T05:14:20.000Z","updated":"2017-07-15T06:26:39.000Z","comments":true,"path":"2017/07/15/android-splash/","link":"","permalink":"http://lx5475.github.io/2017/07/15/android-splash/","excerpt":"","text":"카카오톡, 네이버, 구글 등 여러 앱들은 대부분 스플래시 화면이라고 하는 것을 가지고 있다.앱 실행시 잠깐 로고가 뜨는 화면을 말하는데, 오늘은 그것을 만들어보려고 한다.내가 진행할 강의는 인터넷에 있는 다른 안드로이드 스플래시 화면 만들기 강의랑은 다른점이 있는데, 바로 Thread-Handler를 사용하지 않는다는 것이다.Handler를 사용해서 만드는 방법은 지정한 시간 후에 화면이 넘어가게하는 방법인데, 아래 단점과 같은 이유로 별로다… 여러분의 앱 로고가 아무리 멋지다 하더라도 로딩이 다 끝났는데 스플래시 화면을 봐 줄 사람은 없다. ㅠㅠ Handler 사용시 장점 지정한 시간동안 스플래시 화면을 보여줄 수 있다. 단점 지정한 시간동안 사용자를 억지로 기다리게 한다. 내가 만들 스플래시 화면은 순수하게 앱 로딩이 끝나면 전환되는 스플래시 화면! 이다. drawable 폴더에 background_splash.xml 만들기&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 배경 --&gt; &lt;item android:drawable=\"@color/cardview_light_background\"/&gt; &lt;!-- 로고 --&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 스플래시 이미지가 될 화면이다. 코드로 적혀있어서 무슨 화면이 될지 모르실 분들을 위해서 사진을 준비했다. 앱의 로고를 가운데 넣고, #EEE 정도되는 color를 배경에 깐 모습이다.디자인은 여기에서 여러가지 건드리면된다. xml이 준비되었다면 다음 단계로 넘어가면된다. values/styles.xml 수정하기&lt;resources&gt; ... &lt;!-- 아래 스타일을 추가해 준다 --&gt; &lt;style name=\"SplashTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/background_splash&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; values 폴더 안에 있는 styles.xml에서 새로운 스타일을 하나 추가 해 준다.이름은 SplashTheme 이라고 임의로 명명하겠다. SplashActivity.java 생성public class SplashActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // MainActivity.class 자리에 다음에 넘어갈 액티비티를 넣어주기 Intent intent = new Intent(this, MainActivity.class); intent.putExtra(\"state\", \"launch\"); startActivity(intent); finish(); &#125;&#125; SplashActivity.java 파일을 만들어서 위와 같이 입력해준다.지금은 MainActivity.class로 넘어간다고 했지만, 여러분의 앱의 메인 액티비티 이름을 넣으면된다. AndroidManifest.xml 수정하기&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.gold24park.mcpeguidebook\"&gt; ... &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:name=\"com.gold24park.mapemasterbook.util.AnalyticsApplication\" android:theme=\"@style/AppTheme\"&gt; &lt;!-- 시작 액티비티를 SplashActivity로 설정, android:theme를 SplashTheme로 설정 --&gt; &lt;activity android:name=\"com.gold24park.mapemasterbook.SplashActivity\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.gold24park.mapemasterbook.MainActivity\"&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; AndroidManifest.xml에서 주석을 참고하여 수정하면 완성!","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"앱개발","slug":"앱개발","permalink":"http://lx5475.github.io/tags/앱개발/"},{"name":"스플래시","slug":"스플래시","permalink":"http://lx5475.github.io/tags/스플래시/"},{"name":"인트로","slug":"인트로","permalink":"http://lx5475.github.io/tags/인트로/"},{"name":"splash","slug":"splash","permalink":"http://lx5475.github.io/tags/splash/"},{"name":"intro","slug":"intro","permalink":"http://lx5475.github.io/tags/intro/"}]},{"title":"안드로이드 Retrofit으로 API 통신하기","slug":"android-retrofit","date":"2017-03-29T16:11:50.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2017/03/30/android-retrofit/","link":"","permalink":"http://lx5475.github.io/2017/03/30/android-retrofit/","excerpt":"","text":"이번 강의에서는 안드로이드를 위한 HTTP 클라이언트 레트로핏을 이용해서 API 통신을 구현 해 보도록 하겠다.먼저, JSON 값을 돌려주는 서버가 준비 되어 있어야한다.여기서는 간단히…깃헙 contributors를 통해 살펴보겠다.주소는 https://api.github.com/repos/square/retrofit/contributors 이다. 목표https://api.github.com/repos/square/retrofit/contributors 에 들어가면 아래와 같이 JSON 형식으로 된 정보들이 나온다. 오늘 해볼 것은 저 정보들 중에서 특히 ‘login’ 정보를 TextView에 받아 오는 것이다. build.gradle (app)dependencies &#123; ... compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; ...&#125; retrofit을 앱에 적용시키기 위해서 디펜던시 설정을 해준다.위의 3번째 라인에 있는 한 줄을 추가시켜 주면된다.그리고 컨버터로는 GSON을 사용할 것이기 때문에 아래의 한줄을 더 추가시켜준다.(GSON이외에도 많은 컨버터들을 사용할 수 있다. &gt;&gt; 공식문서 참고)compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; activity_retrofit.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:text=\"TextView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/textView\" /&gt;&lt;/LinearLayout&gt; res &gt; layout에 activity_retrofit.xml 파일을 추가시켜 준다.이 텍스트뷰에 카테고리 정보를 띄울 것이다. RetrofitActivity.javapublic class RetrofitActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_retrofit); &#125;&#125; 위와 같이 RetrofitActivity.java도 구현해준다.이제 본격적으로 Retrofit을 이용 해 보도록 하겠다. Contributor.class 파일 생성public class Contributor &#123; // login 정보를 받아올 것이므로 public final String login; public Contributor(String login) &#123; this.login = login; &#125;&#125; login 필드에 해당하는 정보를 받아올 객체인 Contributor를 새로 만든다. GitHub.interface 파일 생성public interface GitHub &#123; // GET/POST/DELETE/PUT 메소드들을 인터페이스에 구현하여 사용할 수 있다. @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\") // JSON Array를 리턴하므로 List&lt;&gt;가 되었다 Call&lt;List&lt;Contributor&gt;&gt; contributors( // param 값으로 들어가는 것들이다 @Path(\"owner\") String owner, @Path(\"repo\") String repo);&#125; GItHub이라는 인터페이스에는 메소드들을 정의할 수 있다.RESTful한 모든 것들이 다 들어갈 수 있으며 쿼리도 넣을 수 있다. 아래는 그 하나의 예시다.@GET(\"/users/list?sort=desc\") RetrofitActivity.classpublic class RetrofitActivity extends Activity &#123; private Retrofit retrofit; private TextView textView; private final String BASE_URL = \"https://api.github.com\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_retrofit); init(); // GitHub API 인터페이스 생성 GitHub gitHub = retrofit.create(GitHub.class); // 인터페이스에 구현한 메소드인 contributors에 param 값을 넘기는 요청 만ㄷ름 Call&lt;List&lt;Contributor&gt;&gt; call = gitHub.contributors(\"square\", \"retrofit\"); // 앞서만든 요청을 수행 call.enqueue(new Callback&lt;List&lt;Contributor&gt;&gt;() &#123; @Override // 성공시 public void onResponse(Call&lt;List&lt;Contributor&gt;&gt; call, Response&lt;List&lt;Contributor&gt;&gt; response) &#123; List&lt;Contributor&gt; contributors = response.body(); // 받아온 리스트를 순회하면서 for (Contributor contributor : contributors) &#123; // 텍스트 뷰에 login 정보를 붙임 textView.append(contributor.login); &#125; &#125; @Override // 실패시 public void onFailure(Call&lt;List&lt;Contributor&gt;&gt; call, Throwable t) &#123; Toast.makeText(RetrofitActivity.this, \"정보받아오기 실패\", Toast.LENGTH_LONG) .show(); &#125; &#125;); &#125; public void init() &#123; textView = (TextView) findViewById(R.id.textView); // GSON 컨버터를 사용하는 REST 어댑터 생성 retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); &#125;&#125; 다시 액티비티로 돌아와서, 위와 같이 입력해준다. 이제 앱을 실행하면 빠르게 결과가 뜨는 것을 알 수 있다. ^-^","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"통신","slug":"통신","permalink":"http://lx5475.github.io/tags/통신/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://lx5475.github.io/tags/Retrofit/"},{"name":"http","slug":"http","permalink":"http://lx5475.github.io/tags/http/"},{"name":"REST","slug":"REST","permalink":"http://lx5475.github.io/tags/REST/"},{"name":"RESTful","slug":"RESTful","permalink":"http://lx5475.github.io/tags/RESTful/"},{"name":"서버","slug":"서버","permalink":"http://lx5475.github.io/tags/서버/"},{"name":"백엔드","slug":"백엔드","permalink":"http://lx5475.github.io/tags/백엔드/"},{"name":"backend","slug":"backend","permalink":"http://lx5475.github.io/tags/backend/"},{"name":"API","slug":"API","permalink":"http://lx5475.github.io/tags/API/"}]},{"title":"안드로이드 Fragment에 정보 전달하기","slug":"android-fragment","date":"2016-07-27T15:00:00.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/07/28/android-fragment/","link":"","permalink":"http://lx5475.github.io/2016/07/28/android-fragment/","excerpt":"","text":"개발 중 나는 Fragment에 간단한 정보를 전달할 일이 있어Fragment를 생성할 때 constructor를 추가하여 넣었던 적이있다.그런데 빌드시 오류가 났다. non-default 생성자는 Fragment에서 허용되지 않는 듯 보였다. 예를 들어 사용자의 정보인 아이디를 보여주는 Fragment가 있다고 하자.그렇다면 userId라는 String 타입 값을 Fragment에 넘겨줄 방법이 필요하다. 이때 Bundle을 이용하면 마치 Activity간 Intent처럼 넘겨줄 수 있다.Fragment fragment = new UserFragment(); // Fragment 생성Bundle bundle = new Bundle(1); // 파라미터는 전달할 데이터 개수bundle.putString(\"userId\", userId); // key , valuefragment.setArguments(bundle); 이런식으로 말이다. 이렇게 Fragment로 정보를 넘겨주고 나면 Fragment의 onCreateView 메소드 안에서getArguments()를 이용해 간단히 받아와 사용하면 된다.항상 번들이 뭔가 했는데, 이렇게 유용한거였다니! 감동 ㅎㅎ @Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; String userId = getArguments.getString(\"userId\"); // 전달한 key 값 return inflater.inflate(R.layout.fragment_one, null);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/tags/Android/"},{"name":"프래그먼트","slug":"프래그먼트","permalink":"http://lx5475.github.io/tags/프래그먼트/"},{"name":"Bundle","slug":"Bundle","permalink":"http://lx5475.github.io/tags/Bundle/"},{"name":"Fragment","slug":"Fragment","permalink":"http://lx5475.github.io/tags/Fragment/"},{"name":"정보 전송","slug":"정보-전송","permalink":"http://lx5475.github.io/tags/정보-전송/"},{"name":"앱 개발","slug":"앱-개발","permalink":"http://lx5475.github.io/tags/앱-개발/"}]},{"title":"안드로이드 PHP 통신에서 한글 깨짐 해결법","slug":"android-php-korean","date":"2016-07-08T11:18:12.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/07/08/android-php-korean/","link":"","permalink":"http://lx5475.github.io/2016/07/08/android-php-korean/","excerpt":"","text":"안드로이드와 PHP 연동시GET방식으로 한글을 넘겨 줄 때 일부 스마트폰에서 ??? 이렇게 물음표로 뜨는 경우가 있다.이때는 안드로이드에서 String을 보낼 때 해당 한글 부분을 utf-8 방식으로 인코딩 해주면된다. String url = \"http://***.com/login/db_get_messages.php?receiver=\" + URLEncoder.encode(userData.getUserData(\"uname\"),\"utf-8\");","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/tags/Android/"},{"name":"PHP","slug":"PHP","permalink":"http://lx5475.github.io/tags/PHP/"},{"name":"통신","slug":"통신","permalink":"http://lx5475.github.io/tags/통신/"},{"name":"한글","slug":"한글","permalink":"http://lx5475.github.io/tags/한글/"},{"name":"한글깨짐","slug":"한글깨짐","permalink":"http://lx5475.github.io/tags/한글깨짐/"}]},{"title":"안드로이드 Custom Object를 Intent로 넘기기, Parcelable 구현","slug":"android-parcelable","date":"2016-06-27T11:20:00.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/06/27/android-parcelable/","link":"","permalink":"http://lx5475.github.io/2016/06/27/android-parcelable/","excerpt":"","text":"내가 만든 클래스를 넘겨보자!7월 업데이트를 위해 리팩토링을 하면서,데이터 타입에 대한 정리는 끝났으니 이제 전송에 관련된 일을 처리해야했다. 나는 ItemDB라고 하는 클래스를 만들어 아이템 정보를 관리하고 있다.그러나 특성상 ItemDB 자체를 인텐트로 넘겨야 더 좋은 성능을 낼 수 있는 상황이 왔다.intent.putExtra(key, value)로 보내어 value 값이 맞는 아이템을 500개 리스트에서 일일이 찾기 보다는그냥 ItemDB 하나만 심플하게 보내는 방법이 좋아보였다.그러나 putExtra()는 한정된 자료형만 전송할 수 있는 단점이 있기에, 어떻게 해결하면 좋을지 찾아보다가Parcelable 또는 Serializable 을 이용해 커스텀 오브젝트를 전송할 수 있다는 사실을 알게 되었다. ItemDB.classpublic class ItemDB &#123; private final String TYPE_STRING = \"string\"; private final String TYPE_DRAWABLE = \"drawable\"; private int name; private int desc; private float hunger; private float armor; private float cooldown; private String attack; private String pc_ver; private String pe_ver; private String grid; private int icon; private Category category;&#125; 대략 이러한 ItemDB라는 커스텀 클래스가 있다고 치자. (여기에 get/set 메소드를 더한)Parcelable을 이용하기 위해 이를 implement하여 구현해야 한다.이를 구현하고 나면 describeContents()와 writeToParcel(Parcel dest, int flags) 라는 메소드를 처리해야한다.describeContents()같은 경우에는 놔둬도 되고, 중요한 부분은 writeToParcel 부분이다. public class ItemDB implements Parcelable &#123; private final String TYPE_STRING = \"string\"; private final String TYPE_DRAWABLE = \"drawable\"; private int name; private int desc; private float hunger; private float armor; private float cooldown; private String attack; private String pc_ver; private String pe_ver; private String grid; private int icon; private Category category; public ItemDB(Parcel parcel) &#123; // must be same order with writeToParcel() this.name = parcel.readInt(); this.desc = parcel.readInt(); this.icon = parcel.readInt(); this.hunger = parcel.readFloat(); this.armor = parcel.readFloat(); this.cooldown = parcel.readFloat(); this.attack = parcel.readString(); this.pc_ver = parcel.readString(); this.pe_ver = parcel.readString(); this.grid = parcel.readString(); &#125; public ItemDB(...) &#123; // your constructor &#125; // create Parcelable public static final Parcelable.Creator&lt;ItemDB&gt; CREATOR = new Parcelable.Creator&lt;ItemDB&gt;() &#123; @Override public ItemDB createFromParcel(Parcel parcel) &#123; return new ItemDB(parcel); &#125; @Override public ItemDB[] newArray(int size) &#123; return new ItemDB[size]; &#125; &#125;; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.name); dest.writeInt(this.desc); dest.writeInt(this.icon); dest.writeFloat(this.hunger); dest.writeFloat(this.armor); dest.writeFloat(this.cooldown); dest.writeString(this.attack); dest.writeString(this.pc_ver); dest.writeString(this.pe_ver); dest.writeString(this.grid); &#125; @Override public int describeContents() &#123; return 0; &#125; public int getName &#123; return this.name; &#125;&#125; 구현한 모습이다!35행은 Parcelable을 생성하는 코드다.writeToParcel에서 Parcel 목적지(dest)에다가 데이터를 포맷에 따라 차곡차곡 넣어주고,Parcel이 있는 생성자에서 순서대로 꺼내오면 된다. (두 개의 순서는 같아야 한다!)이제 Parcel을 구현했으니 직접 Intent로 옮겨보자! 내 앱은 ItemListActivity에서 아이템을 클릭하면 ItemInfoActivity로 넘어가게 된다. ItemListActivity.javapublic class ItemListActivity extends Activity &#123; ... pubic void startActivityByItem(ItemDB item) &#123; Intent intent = new Intent(this, ItemInfoActivity.class); intent.putExtra(ITEM_KEY, item); startActivity(intent); &#125;&#125; String 으로 키 값을 주고, ItemDB 자체를 넘겨주는게 이제는 된다!그러면 받는건 어떻게 하는지 보자. ItemInfoActivity.javapublic class ItemListActivity extends Activity &#123; ... ItemDB item = (ItemDB) getIntent().getParcelableExtra(ITEM_KEY); Log.e(\"[ITEM] 이름 :\", getResources().getString(item.getName()));&#125; 이런식으로 하면 Log에서는 클릭한 아이템 이름이 나오게 된다! 코코아 콩과 나침반을 누르니 정말 코코아 콩과 나침반이 찍힌다!귀여워~","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/tags/Android/"},{"name":"Custom","slug":"Custom","permalink":"http://lx5475.github.io/tags/Custom/"},{"name":"Object","slug":"Object","permalink":"http://lx5475.github.io/tags/Object/"},{"name":"parcelable","slug":"parcelable","permalink":"http://lx5475.github.io/tags/parcelable/"},{"name":"intent","slug":"intent","permalink":"http://lx5475.github.io/tags/intent/"},{"name":"넘기기","slug":"넘기기","permalink":"http://lx5475.github.io/tags/넘기기/"},{"name":"오브젝트","slug":"오브젝트","permalink":"http://lx5475.github.io/tags/오브젝트/"},{"name":"Serializable","slug":"Serializable","permalink":"http://lx5475.github.io/tags/Serializable/"},{"name":"Parcel","slug":"Parcel","permalink":"http://lx5475.github.io/tags/Parcel/"}]},{"title":"안드로이드 앱 최초 실행시 바탕화면에 아이콘(Shortcut) 생성하기","slug":"android-shortcut","date":"2016-03-29T11:01:12.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/03/29/android-shortcut/","link":"","permalink":"http://lx5475.github.io/2016/03/29/android-shortcut/","excerpt":"","text":"안드로이드 앱 최초 실행시 자동으로 바탕화면에 아이콘(shortcut)을 생성해주는 코드다.SharedPreferences의 “check”라는 키를 이용해해당 키의 value가 비어있으면(isEmpty()) shortcut을 생성하고,그 후에는 “exist”라는 value를 채워준다. SharedPreferences는 이렇듯 간단한 ON/OFF 설정에 이용하면 좋다.사용법도 SQLDatabase보다 간단하며앱이 삭제되지 않는 한 계속 지속되기 때문이다. if(pref.getString(“check”,””).isEmpty()) 이하 코드를 다르게 해서앱 최초 실행시 취할 액션을 마음대로 꾸며보는 것도 좋다. //데스크탑 아이콘 생성public void createDesktopIcon() &#123; SharedPreferences pref = getSharedPreferences(\"pref\", MODE_PRIVATE); pref.getString(\"check\", \"\"); if(pref.getString(\"check\", \"\").isEmpty())&#123; Intent shortcutIntent = new Intent(Intent.ACTION_MAIN); shortcutIntent.addCategory(Intent.CATEGORY_LAUNCHER); shortcutIntent.setClassName(this, getClass().getName()); shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK| Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); Intent intent = new Intent(); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getResources().getString(R.string.app_name)); //앱 이름 intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(this, R.drawable.ic_launcher)); //앱 아이콘 intent.putExtra(\"duplicate\", false); intent.setAction(\"com.android.launcher.action.INSTALL_SHORTCUT\"); sendBroadcast(intent); &#125; SharedPreferences.Editor editor = pref.edit(); editor.putString(\"check\", \"exist\"); editor.commit();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"앱","slug":"앱","permalink":"http://lx5475.github.io/tags/앱/"},{"name":"어플","slug":"어플","permalink":"http://lx5475.github.io/tags/어플/"},{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/tags/Android/"},{"name":"Shortcut","slug":"Shortcut","permalink":"http://lx5475.github.io/tags/Shortcut/"},{"name":"바탕화면","slug":"바탕화면","permalink":"http://lx5475.github.io/tags/바탕화면/"},{"name":"배경","slug":"배경","permalink":"http://lx5475.github.io/tags/배경/"},{"name":"아이콘","slug":"아이콘","permalink":"http://lx5475.github.io/tags/아이콘/"},{"name":"생성","slug":"생성","permalink":"http://lx5475.github.io/tags/생성/"},{"name":"바로가기","slug":"바로가기","permalink":"http://lx5475.github.io/tags/바로가기/"},{"name":"개발","slug":"개발","permalink":"http://lx5475.github.io/tags/개발/"}]},{"title":"안드로이드 화면 전환, 액티비티 간 정보 전송 (인텐트,Intent)","slug":"android-intent","date":"2016-01-27T01:49:23.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/01/27/android-intent/","link":"","permalink":"http://lx5475.github.io/2016/01/27/android-intent/","excerpt":"","text":"안드로이드에서 인텐트(Intent)는 기본이다.고등학교 때 100% 열정만으로 뛰어든 앱 개발에 가장 당황했던 것은 그 흔한 화면 넘기기 조차 자바 코드였다는 사실이다.특히나 그 때 자바 문법에 대한 지식이 1도 없어서 인텐트는 사용해보지도 못했다. (그래서 Tab으로 구현했는데 이것도 이상하네..)그래서 이번에는 인텐트에 대해서 정리를 해서 나처럼 화면전환을 못하는 사람에게 도움을 주려한다. 인텐트는 어떤 일을 할 수 있는가?인텐트는 A Activity에서 어떤 동작이 발생하면, B Activity를 실행하는 화면 전환의 기능을 할 수 있다.그리고 A Activity에서 발생하는 어떤 형태의 데이터(int,String,char,float,array…etc)를 B Activity로 넘길 수 있다. 인텐트 사용법인텐트 사용법의 예시를 보기 위해MainActivity.java === activity_main.xmlSubActivity.java === activity_sub.xml이렇게 두가지의 화면과 두가지의 액티비티가 있고, MainActivity에서 SubActivity로 화면 전환을 해야한다고 가정하자.MainActivity에 있는 버튼을 누르면, SubActivity로 넘어갈 것이다. activity_main.xml여기서는 화면 전환을 위한 버튼을 하나 생성한다.&lt;Buttonandroid:id=\"@+id/btn_next\"android:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:text=\"화면전환\"/&gt; 그러면 ‘화면전환’이라는 라벨이 달린 버튼이 하나 생성 될 것이다.이것에 OnClickListener를 달아 버튼이 눌리면 인텐트를 실행시키기 위해 MainActivity.java를 열어 수정한다. MainActivity.javapublic class MainActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn_go = (Button) findViewById(R.id.btn_go); btn_go.setOnClickListener( new Button.OnClickListener() &#123; public void onClick(View v) &#123; //SubActivity로 가는 인텐트를 생성 Intent intent = new Intent(this, SubActivity.class); //액티비티 시작! startActivity(intent); &#125; &#125; ); &#125;&#125; 이렇게 까지 하면 MainActivity에 있는 버튼을 누르면 SubActivity로 넘어갈 것이다.오류가 뜬다고…? 그것은 아마 SubActivity를 AndroidManifest.xml 파일에 등록해주지 않아서이다.&lt;activity android:name=&quot;.SubActivity&quot;&gt;&lt;/activity&gt;위 한 줄을 &lt;activity android:name=&quot;.MainActivity&quot;&gt;...&lt;/activity&gt; 바로 밑에 추가해주자! activity_sub.xml이제 화면 전환까지는 했으니 정보를 주고 받는 일을 해보겠다.MainActivity의 버튼을 누르면 “jizard”와 119라는 정보 두가지를 전달 해 보겠다. 보다시피 하나는 String, 하나는 int 타입이다.SubActivity 에서는 받아 온 값을 TextView에 출력할 것이다. 값이 2개이므로 TextView를 두개 만든다.&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/username\"/&gt;&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/birthday\"/&gt; username이란 id를 가진 TextView에는 “jizard”를, birthday에는 119를 넣을 것이다.정보 전송을 위해 다시 MainActivity를 수정한다. MainActivity.javapublic class MainActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn_go = (Button) findViewById(R.id.btn_go); btn_go.setOnClickListener( new Button.OnClickListener() &#123; public void onClick(View v) &#123; //SubActivity로 가는 인텐트를 생성 Intent intent = new Intent(this, SubActivity.class); intent.putExtra(\"USERNAME_KEY\",\"jizard\"); //키 - 보낼 값(밸류) intent.putExtra(\"BIRTHDAY_KEY\",119); //액티비티 시작! startActivity(intent); &#125; &#125; ); &#125;&#125; putExtra에다가 원하는 값을 넣어주면 된다.그런데 원하는 값 앞에있는 “USERNAME_KEY” 같은건 뭐냐?!컴퓨터공학도들이나 자료구조에 대해 약간 배운 사람들은 Key-Value 관계를 잘 안다.하지만 비전공자들에겐 생판 처음 보는 것들이다. 왜 값을 두개나 보내지라고 생각할지도…말하자면 이름을 붙여주는 것이다. 지금은 “jizard”라는 특정 값을 전달하지만 혹시나 유저가 임의로 만든 문자를 전달하는 상황이 올지도 모른다.그래서 프로그램에서 처리하기 쉽도록 ‘그 값의 이름은 “USERNAME_KEY”니까 그 놈으로 가져와라.’하는 것이다.2학년 5반 37번이라고 이름짓는 거랑 똑같다.그럼 이제 2학년 5반 37번 아이를 불러보는 일을 SubActivity에서 해보자. SubActivity.javapublic class SubActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sub); TextView tv_username = (TextView) findViewById(R.id.tv_username); TextView tv_birthady = (TextView) findViewById(R.id.tv_birthday); Intent intent = getIntent(); //이 액티비티를 부른 인텐트를 받는다. String username = intent.getStringExtra(\"USERNAME_KEY\"); //\"jizard\"문자 받아옴 int birthday = intent.getIntExtra(\"BIRTHDAY_KEY\",0); //119 받아옴 tv_username.setText(username); tv_birthday.setText(String.valueOf(birthday)); &#125;&#125; 인텐트를 받기 위해서 여기서도 인텐트를 하나 생성한다.예전에 잘 몰랐을땐 이 액티비티 호출한 인텐트랑 여기서 만든 인텐트랑 변수명이 다르면 작동이 안될까봐…ㅋㅋ무조건 같게했었는데, 그럴 필요는 없다…intent에서 String 값을 받아오기 위해서는 getStringExtra(String key)를 사용하며int 값을 받아오기 위해서는 getIntExtra(String key, int defaultValue)를 사용한다.int를 불러올 땐 인텐트 값을 받아오지 못했을 때 설정할 기본 값을 주는 것이다. 그럼 String을 못받아오면? null 이된다.이러한 것은 Intent에 관한 구글 안드로이드 API에 다 있다. 영어로 적혀있어서 읽기 싫은건 사실이지만,백번 천번 도움되니 API는 꼭 읽기를 바란다!","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"개발자","slug":"개발자","permalink":"http://lx5475.github.io/tags/개발자/"},{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/tags/Android/"},{"name":"정보 전송","slug":"정보-전송","permalink":"http://lx5475.github.io/tags/정보-전송/"},{"name":"화면 전환","slug":"화면-전환","permalink":"http://lx5475.github.io/tags/화면-전환/"},{"name":"액티비티 전환","slug":"액티비티-전환","permalink":"http://lx5475.github.io/tags/액티비티-전환/"},{"name":"activity","slug":"activity","permalink":"http://lx5475.github.io/tags/activity/"},{"name":"Intent","slug":"Intent","permalink":"http://lx5475.github.io/tags/Intent/"},{"name":"인텐트","slug":"인텐트","permalink":"http://lx5475.github.io/tags/인텐트/"}]},{"title":"안드로이드 버튼 클릭 이벤트 처리 (Android Button Click Event)","slug":"android-button-tutorial","date":"2016-01-26T12:59:55.000Z","updated":"2017-07-15T10:55:09.000Z","comments":true,"path":"2016/01/26/android-button-tutorial/","link":"","permalink":"http://lx5475.github.io/2016/01/26/android-button-tutorial/","excerpt":"","text":"안드로이드를 개발하면서 버튼을 클릭하면 나타나는 클릭이벤트를 구현하는 상황을 많이 마주한다! 그럴때마다 나는 구글에 검색해서 코드 복붙을 했는데, 이번 기회에 한번에 정리한다. 안드로이드 버튼 클릭 이벤트를 구현하는 방법은 다양하다.그 중에서 4가지를 소개할텐데, 아무거나, 편한대로 쓰면된다. 버튼 xml 준비하기activity_main.xml&lt;Buttonandroid:id=\"@+id/btn_start\"android:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:text=\"Start\"/&gt; Activity에 구현하기MainActivity.javaactivity_main.xml에 있는 버튼 이벤트를 적어주어야 하는 곳은setContentView(R.layout.activity_main)이라는 코드가 있는 MainActivity.java이다. 다음의 4가지 방법 중 아무거나 쓰면 된다. 1) OnClickListener 따로 만들어 구현하는 방법첫번째 방법은 onClickListener를 따로 하나 만들고, activity_main.xml에 있는 버튼을 불러와서 버튼에 해당 리스너를 연결시키는 방법이다.findViewById(R.id.btn_start).setOnClickListener(mClickListener); 대신에Button btn_start = (Button) findViewById(R.id.btn_start);btn_start.setOnClickListener(mClickListener); 라고 적어주어도 된다. public class MainActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_start).setOnClickListener(mClickListener); &#125; Button.OnClickListener mClickListener = new View.OnClickListener() &#123; public void onClick(View v) &#123; //이곳에 버튼 클릭시 일어날 일을 적습니다. &#125; &#125; &#125;;&#125; 2) OnClickListener를 생성과 동시에 만드는 방법두번째 방법은 만들어 놓은 OnClickListener를 연결시키는 것이 아니라, 바로 새로운 OnClickListener를 만드는 방법이다.생성자 new를 이용하여 OnClickListener를 만들면된다. public class MainActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_start).setOnClickListener( new Button.OnClickListener() &#123; public void onClick(View v) &#123; //여기에 이벤트를 적어주세요 &#125; &#125; ); &#125;&#125; 3) Activity에 OnClickListener 인터페이스를 구현하는 방법세번째 방법은 MainActivity.java에 OnClickListener를 implement하여 구현하는 방법이다. MainActivity가 View.OnClickListener 인터페이스를 받는다. 그러면 이 액티비티에는 public void onClick() 메소드가 생긴다. 여기다가 할 일을 적고, 버튼의 OnClickListener로 이 액티비티(this)를 연결시켜주면 된다. public class MainActivity extends Activity implements View.OnClickListener&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn_start =(Button)findViewById(R.id.btn_start); btn_start.setOnClickListener(this); &#125; public void onClick(View v) &#123; //여기에 할 일을 적어주세요. &#125;&#125; 4) xml 상에서 onClick 속성을 이용하는 방법이 방법은 activity_main.xml button 부분에 onClick=&quot;&quot; 추가해주는 방법이다.굳이 버튼이 아니더라도 RelativeLayout이건 어디건 다 쓸 수 있다.나는 이것을 활용하여 길쭉한 버튼을 만들때 그냥 RelativeLayout에다 onClick 속성을 써서 버튼 이벤트를 구현한다. activity.xml&lt;Buttonandroid:id=\"@+id/btn_start\"android:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:onClick=\"btnStart\"android:text=\"Start\"/&gt; 여기서 onClick=&quot;변수이름&quot; 에 주목!MainActivity.java에서는 그 변수이름으로 메소드를 만든다. MainActivity.javapublic class MainActivity extends Activity&#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void btnStart(View v) &#123; //여기에다 할 일을 적어주세요. &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://lx5475.github.io/categories/Android/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://lx5475.github.io/tags/안드로이드/"},{"name":"android","slug":"android","permalink":"http://lx5475.github.io/tags/android/"},{"name":"개발자","slug":"개발자","permalink":"http://lx5475.github.io/tags/개발자/"},{"name":"만들기","slug":"만들기","permalink":"http://lx5475.github.io/tags/만들기/"},{"name":"버튼","slug":"버튼","permalink":"http://lx5475.github.io/tags/버튼/"},{"name":"button","slug":"button","permalink":"http://lx5475.github.io/tags/button/"},{"name":"앱","slug":"앱","permalink":"http://lx5475.github.io/tags/앱/"},{"name":"앱개발","slug":"앱개발","permalink":"http://lx5475.github.io/tags/앱개발/"},{"name":"어플","slug":"어플","permalink":"http://lx5475.github.io/tags/어플/"},{"name":"이벤트","slug":"이벤트","permalink":"http://lx5475.github.io/tags/이벤트/"},{"name":"처리","slug":"처리","permalink":"http://lx5475.github.io/tags/처리/"},{"name":"클릭","slug":"클릭","permalink":"http://lx5475.github.io/tags/클릭/"},{"name":"강의","slug":"강의","permalink":"http://lx5475.github.io/tags/강의/"},{"name":"만드는법","slug":"만드는법","permalink":"http://lx5475.github.io/tags/만드는법/"}]}]}